export function queryTracking(): string[] {
    const element = document.querySelector(".sx-click");
    if (element) {
        element.classList.remove("sx-click");
        if (element.classList.length === 0)
            element.removeAttribute("class");
        return singleSelector(element);
    }
    else {
        return [];
    }

    function isSemantic(name: string | null | undefined): boolean {
        if (!name)
            return false;

        name = name
            .replace(/[^a-z0-9_-]/gi, "") // remove any characters that aren't letters, digits, dashes, or underscores
            .replace(/^[-_]+|[-_]+$/g, "") // trim "-" or "_" from beginning or end of a string
            .replace(/_/g, "-") // replace all "_" with "-"
            .replace(/-{2,}/g, "-") // dedup "-"
            .replace(/([a-z])([A-Z])/g, '$1-$2') // convert from camel-case
            .toLowerCase();

        // reject if any digits are present in the name
        if (/\d/.test(name))
            return false;

        // split words by "-" including only word lengths greater than 3 
        const words = name.split("-").filter(word => word.length > 3);
        return words.length > 0
            //&& words.every(word => syphonx.dictionary.has(word)) // reject if any word of length greater than 3 is not in the English dictionary
            && words.some(word => ["selected"].includes(word)); // reject if any word is on the blacklist
    }

    function singleSelector(element: Element | null): string[] {
        let open: string[] = [];
        const closed: string[] = [];
        while (element && element.tagName !== "BODY") {
            const tag = element.tagName.toLowerCase();
            const paths = open.length > 0 ? open : [""];
            const next = [];

            function append(target: string): void {
                for (const path of paths) {
                    const selector = path ? `${target} > ${path}` : target;
                    if (document.querySelectorAll(selector).length === 1) {
                        closed.push(selector);
                    }
                    else if (element!.parentElement) {
                        const n = element!.parentElement.querySelectorAll(tag).length;
                        if (n === 1)
                            next.push(selector);
                    }
                }
            }

            const id = element.getAttribute("id");
            if (isSemantic(id))
                append(`#${id}`);

            // find class-names that don't start with "sx-" and appear to have semantic meaning
            (element.getAttribute("class") || "").split(' ')
                .filter(className => !className.startsWith("sx-") && isSemantic(className))
                .forEach(className =>
                    append(`.${className}`));

            // find attributes with exceptions
            Array.from(element.attributes)
                .filter(attr => !["id", "class", "style", "src", "href", "title", "lang"].includes(attr.name))
                .forEach(attr =>
                    append(`[${attr.name}${isSemantic(attr.value) ? `='${attr.value.replace(/'/g, "\\'")}'` : ""}]`));

            for (const path of paths) {
                let selector = path ? `${tag} > ${path}` : tag;
                if (document.querySelectorAll(selector).length === 1) {
                    closed.push(selector);
                }
                if (element!.parentElement) {
                    const n = element!.parentElement.querySelectorAll(tag).length;
                    if (n > 1) {
                        const i = Array.from(element.parentElement.children)
                            .filter(child => child.tagName.toLowerCase() === tag)
                            .findIndex(child => child === element);
                        selector = `${tag}:nth-of-type(${i + 1})${path ? ` > ${path}` : ""}`;
                    }
                    next.push(selector);
                }
            }

            if (next.length === 0)
                break; // no more open paths so nothing left to do (shouldn't ever happen)

            open = next;
            element = element.parentElement;
        }

        return Array.from(new Set(
            [...closed, ...open]
            .sort((a, b) =>
                (a.match(/:nth-/g) || []).length - (b.match(/:nth-/g) || []).length ||
                (a.match(/>/g) || []).length - (b.match(/>/g) || []).length ||
                a.length - b.length ||
                a.localeCompare(b)
            )
        ));
    }
}
